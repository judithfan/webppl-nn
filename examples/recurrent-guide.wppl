var iterate = function(n, prev, f) {
  if (n === 0) {
    return [];
  } else {
    var newval = f(prev);
    return [newval].concat(iterate(n - 1, newval, f));
  }
};

var predictNet = affine(2, 'predict');

var predict = function(state) {
  var out = predictNet(state.ctx);
  return {
    mu: T.get(out, 0),
    sigma: Math.exp(T.get(out, 1))
  };
};

var ctxdim = 4;
// This is capable of spotting the correlation on models of length of
// at least 50, with just 4 hidden units.
var recurrentNet = linearRNN(ctxdim, 'recurrent-net');

// TODO: Next, try additional correlations, non-linear correlations?

var update = function(state, val) {
  // Added `pos` for the linearRNN. This is important (perhaps
  // crucial) to make that work. My sense is that by initializing this
  // to zero, we avoid swamping the net with noise (from sampled
  // values) at the beginning of optimization. Values useful for
  // modeling the correlation can be added, other ignored. Similarly,
  // it also ensures that the hidden state of the RNN (which has no
  // non-linearities) doesn't get out of control.
  var pos = param({name: 'pos' + state.pos, mu: 0, sigma: 0});
  var newCtx = recurrentNet(state.ctx, Vector([val * pos]));
  return {
    val: val,
    ctx: newCtx,
    pos: state.pos + 1
  };
};

var step = function(state) {
  var val = sample(Gaussian({mu: 0, sigma: 1}), {guide() {
    return Gaussian(predict(state));
  }});
  return update(state, val);
};

var prior = function(n) {
  var initialState = {pos: 0, ctx: param({name: 'ctx0', dims: [ctxdim, 1]})};
  return iterate(n, initialState, step);
};

var model = function(n) {
  var steps = prior(n);
  var vals = _.pluck(steps, 'val');
  assert.ok(vals.length >= 2);
  var x = first(vals);
  var y = last(vals);
  var score = -40 * Math.pow(x - y, 2);
  factor(score);
  return {x, y};
};

// var m = Infer({
//   model() { return model(2); },
//   method: 'MCMC',
//   kernel: {HMC: {}},
//   samples: 100,
//   burn: 500
// });
// viz(m);

var m = Infer({
  method: 'optimize',
  samples: 100,
  model() { return model(2); },
  steps: 10000
});
viz(m);
